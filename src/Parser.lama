-- Parser

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun bopl(this, next, oph:opt) {
  fun mapper(op) {
    syntax (lhs=this s[op] rhs=next {Binop (op, lhs, rhs)} | x=next {x})
  }
  foldl(infix |, mapper(oph), map(mapper, opt))
}

var binopAdapter = fun (l, op, r) { Binop (op, l, r) };

fun bops(ops) {
  map(fun (op) { [s(op), binopAdapter] }, ops)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
       exp = expr(
  {
    [Left, bops({"!!"})],
    [Left, bops({"&&"})],
    [Nona, bops({"<", "<=", "!=", "==", ">=", ">"})],
    [Left, bops({"+", "-"})],
    [Left, bops({"*", "/", "%"})]
  }, primary);

var stmt = memo $ eta syntax (kRead s["("] x=lident s[")"] {Read (x)} |
                              kWrite s["("] x=exp s[")"] {Write (x)} |
                              kSkip {Skip} |
                              x=lident s[":="] e=exp {Assn (x, e)});


-- Public top-level parser
public parse = memo $ eta syntax (x=parse s[";"] y=stmt {Seq (x, y)} | x=stmt {x});

