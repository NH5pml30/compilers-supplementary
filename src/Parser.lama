-- Parser

import Ostap;
import Lexer;
import List;
import Fun;
import Matcher;

-- A parser of "something" in brackets; l, r are left and right
-- brackets as parsers, p --- a parser of "something"
fun inbr (l, p, r) {
  syntax (-l p -r)
}

fun bopl(this, next, oph:opt) {
  fun mapper(op) {
    syntax (lhs=this s[op] rhs=next {Binop (op, lhs, rhs)} | x=next {x})
  }
  foldl(infix |, mapper(oph), map(mapper, opt))
}

var binopAdapter = fun (l, op, r) { Binop (op, l, r) };

fun bops(ops) {
  map(fun (op) { [s(op), binopAdapter] }, ops)
}

-- Primary expression
var primary = memo $ eta syntax (x=decimal {Const (stringInt (x))} |
                                 x=lident  {Var (x)}               |
                                 inbr[s("("), exp, s(")")]),
       exp = expr(
  {
    [Left, bops({"!!"})],
    [Left, bops({"&&"})],
    [Nona, bops({"<", "<=", "!=", "==", ">=", ">"})],
    [Left, bops({"+", "-"})],
    [Left, bops({"*", "/", "%"})]
  }, primary);

var stmt = memo $ eta syntax (kRead s["("] x=lident s[")"] {Read (x)} |
                              kWrite s["("] x=exp s[")"] {Write (x)} |
                              kSkip {Skip} |
                              x=lident s[":="] e=exp {Assn (x, e)} |
                              kIf cond=exp kThen ifBody=parse elseBody=elsePart kFi {If (cond, ifBody, elseBody)} |
                              kIf cond=exp kThen ifBody=parse kFi {If (cond, ifBody, Skip)} |
                              kWhile cond=exp kDo body=parse kOd {While (cond, body)} |
                              kDo body=parse kWhile cond=exp kOd {DoWhile (body, cond)} |
                              kFor init=parse s[","] cond=exp s[","] iter=parse kDo body=parse kOd
                                {Seq (init, While (cond, Seq (body, iter)))});

var elsePart = memo $ eta syntax (kElif cond=exp kThen elifBody=parse elseBody=elsePart {If (cond, elifBody, elseBody)} |
                                  kElif cond=exp kThen elifBody=parse {If (cond, elifBody, Skip)} |
                                  kElse elseBody=parse {elseBody});


-- Public top-level parser
public parse = memo $ eta syntax (x=parse s[";"] y=stmt {Seq (x, y)} | x=stmt {x});

